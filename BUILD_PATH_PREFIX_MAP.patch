Index: gcc-7-20170319/gcc/c-family/c-common.c
===================================================================
--- gcc-7-20170319.orig/gcc/c-family/c-common.c
+++ gcc-7-20170319/gcc/c-family/c-common.c
@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.
 
 #include "config.h"
 #include "system.h"
+#include "prefix-map.h"
 #include "coretypes.h"
 #include "target.h"
 #include "function.h"
@@ -8005,6 +8006,33 @@ cb_get_source_date_epoch (cpp_reader *pf
   return (time_t) epoch;
 }
 
+/* Read BUILD_PATH_PREFIX_MAP from environment to have deterministic relative
+   paths to replace embedded absolute paths to get reproducible results.
+   Returns NULL if BUILD_PATH_PREFIX_MAP is not defined or badly formed.  */
+
+prefix_maps *
+cb_get_build_path_prefix_map (cpp_reader *pfile ATTRIBUTE_UNUSED)
+{
+  const char *arg;
+  prefix_maps *map;
+
+  arg = getenv ("BUILD_PATH_PREFIX_MAP");
+  if (!arg)
+    return NULL;
+
+  map = XNEW (prefix_maps);
+  memset (map, 0, sizeof (prefix_maps));
+
+  if (parse_prefix_maps (arg, map))
+    return map;
+
+  free (map);
+  error_at (input_location, "environment variable BUILD_PATH_PREFIX_MAP must "
+	    "be of the form ${old}=${new}");
+
+  return NULL;
+}
+
 /* Callback for libcpp for offering spelling suggestions for misspelled
    directives.  GOAL is an unrecognized string; CANDIDATES is a
    NULL-terminated array of candidate strings.  Return the closest
Index: gcc-7-20170319/gcc/c-family/c-common.h
===================================================================
--- gcc-7-20170319.orig/gcc/c-family/c-common.h
+++ gcc-7-20170319/gcc/c-family/c-common.h
@@ -1085,6 +1085,11 @@ extern time_t cb_get_source_date_epoch (
    __TIME__ can store.  */
 #define MAX_SOURCE_DATE_EPOCH HOST_WIDE_INT_C (253402300799)
 
+/* Read BUILD_PATH_PREFIX_MAP from environment to have deterministic relative
+   paths to replace embedded absolute paths to get reproducible results.
+   Returns NULL if BUILD_PATH_PREFIX_MAP is not defined or badly formed.  */
+extern prefix_maps *cb_get_build_path_prefix_map (cpp_reader *pfile);
+
 /* Callback for libcpp for offering spelling suggestions for misspelled
    directives.  */
 extern const char *cb_get_suggestion (cpp_reader *, const char *,
Index: gcc-7-20170319/gcc/c-family/c-lex.c
===================================================================
--- gcc-7-20170319.orig/gcc/c-family/c-lex.c
+++ gcc-7-20170319/gcc/c-family/c-lex.c
@@ -81,6 +81,7 @@ init_c_lex (void)
   cb->read_pch = c_common_read_pch;
   cb->has_attribute = c_common_has_attribute;
   cb->get_source_date_epoch = cb_get_source_date_epoch;
+  cb->get_build_path_prefix_map = cb_get_build_path_prefix_map;
   cb->get_suggestion = cb_get_suggestion;
 
   /* Set the debug callbacks if we can use them.  */
Index: gcc-7-20170319/gcc/doc/invoke.texi
===================================================================
--- gcc-7-20170319.orig/gcc/doc/invoke.texi
+++ gcc-7-20170319/gcc/doc/invoke.texi
@@ -26634,6 +26634,26 @@ Recognize EUCJP characters.
 If @env{LANG} is not defined, or if it has some other value, then the
 compiler uses @code{mblen} and @code{mbtowc} as defined by the default locale to
 recognize and translate multibyte characters.
+
+@item BUILD_PATH_PREFIX_MAP
+@findex BUILD_PATH_PREFIX_MAP
+If this variable is set, it specifies a mapping that is used to
+transform filepaths that are output in debug symbols, as well as
+filepaths emitted when the __FILE__ macro is expanded.  This helps the
+embedded paths become reproducible, without having the unreproducible
+value be visible in other input sources---such as GCC command-line flags
+or standardised build-time environment variables like
+@code{CFLAGS}---that are commonly legitimately-embedded in the build
+output by higher-level build processes.
+
+The form and behaviour is similar to @option{-fdebug-prefix-map}.  That
+is, the value of @env{BUILD_PATH_PREFIX_MAP} must be of the form
+@samp{@var{old}=@var{new}}.  The split occurs on the last @code{=}
+character, so that @var{new} cannot itself contain a @code{=}.
+
+Whenever an absolute source- or build-related filepath is to be emitted
+in a final end-result output, GCC will replace @var{old} with @var{new}
+if that filepath starts with @var{old}.
 @end table
 
 @noindent
Index: gcc-7-20170319/gcc/final.c
===================================================================
--- gcc-7-20170319.orig/gcc/final.c
+++ gcc-7-20170319/gcc/final.c
@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.
 #define INCLUDE_ALGORITHM /* reverse */
 #include "system.h"
 #include "coretypes.h"
+#include "prefix-map.h"
 #include "backend.h"
 #include "target.h"
 #include "rtl.h"
@@ -1506,22 +1507,9 @@ asm_str_count (const char *templ)
   return count;
 }
 
-/* ??? This is probably the wrong place for these.  */
-/* Structure recording the mapping from source file and directory
-   names at compile time to those to be embedded in debug
-   information.  */
-struct debug_prefix_map
-{
-  const char *old_prefix;
-  const char *new_prefix;
-  size_t old_len;
-  size_t new_len;
-  struct debug_prefix_map *next;
-};
-
-/* Linked list of such structures.  */
-static debug_prefix_map *debug_prefix_maps;
 
+/* Linked list of `struct prefix_map'.  */
+static prefix_maps debug_prefix_maps = { NULL, 0 };
 
 /* Record a debug file prefix mapping.  ARG is the argument to
    -fdebug-prefix-map and must be of the form OLD=NEW.  */
@@ -1529,23 +1517,44 @@ static debug_prefix_map *debug_prefix_ma
 void
 add_debug_prefix_map (const char *arg)
 {
-  debug_prefix_map *map;
+  prefix_map *map;
   const char *p;
 
   p = strchr (arg, '=');
   if (!p)
     {
-      error ("invalid argument %qs to -fdebug-prefix-map", arg);
+      error ("invalid value %qs for debug-prefix-map", arg);
       return;
     }
-  map = XNEW (debug_prefix_map);
+  map = XNEW (prefix_map);
   map->old_prefix = xstrndup (arg, p - arg);
   map->old_len = p - arg;
   p++;
   map->new_prefix = xstrdup (p);
   map->new_len = strlen (p);
-  map->next = debug_prefix_maps;
-  debug_prefix_maps = map;
+
+  map->next = debug_prefix_maps.head;
+  debug_prefix_maps.head = map;
+  if (map->new_len > debug_prefix_maps.max_replace)
+    debug_prefix_maps.max_replace = map->new_len;
+}
+
+/* Add a debug-prefix-map using the BUILD_PATH_PREFIX_MAP environment variable if
+   it is set.  */
+
+void
+add_debug_prefix_map_from_envvar ()
+{
+  char *prefix_map;
+
+  prefix_map = getenv ("BUILD_PATH_PREFIX_MAP");
+  if (!prefix_map)
+    return;
+
+  if (parse_prefix_maps (prefix_map, &debug_prefix_maps))
+    return;
+  
+  error ("bad format for BUILD_PATH_PREFIX_MAP");
 }
 
 /* Perform user-specified mapping of debug filename prefixes.  Return
@@ -1554,22 +1563,13 @@ add_debug_prefix_map (const char *arg)
 const char *
 remap_debug_filename (const char *filename)
 {
-  debug_prefix_map *map;
-  char *s;
-  const char *name;
-  size_t name_len;
-
-  for (map = debug_prefix_maps; map; map = map->next)
-    if (filename_ncmp (filename, map->old_prefix, map->old_len) == 0)
-      break;
-  if (!map)
+  char *newname;
+  const char *name = remap_prefix_alloca (filename, &debug_prefix_maps, newname);
+
+  if (name == filename)
     return filename;
-  name = filename + map->old_len;
-  name_len = strlen (name) + 1;
-  s = (char *) alloca (name_len + map->new_len);
-  memcpy (s, map->new_prefix, map->new_len);
-  memcpy (s + map->new_len, name, name_len);
-  return ggc_strdup (s);
+
+  return ggc_strdup (newname);
 }
 
 /* Return true if DWARF2 debug info can be emitted for DECL.  */
Index: gcc-7-20170319/gcc/opts-global.c
===================================================================
--- gcc-7-20170319.orig/gcc/opts-global.c
+++ gcc-7-20170319/gcc/opts-global.c
@@ -335,6 +335,8 @@ handle_common_deferred_options (void)
   if (flag_opt_info)
     opt_info_switch_p (NULL);
 
+  add_debug_prefix_map_from_envvar ();
+
   FOR_EACH_VEC_ELT (v, i, opt)
     {
       switch (opt->opt_index)
Index: gcc-7-20170319/gcc/testsuite/gcc.dg/cpp/build_path_prefix_map-1.c
===================================================================
--- /dev/null
+++ gcc-7-20170319/gcc/testsuite/gcc.dg/cpp/build_path_prefix_map-1.c
@@ -0,0 +1,11 @@
+/* __FILE__ should strip BUILD_PATH_PREFIX_MAP if the latter is a prefix. */
+/* { dg-do run } */
+/* { dg-set-compiler-env-var BUILD_PATH_PREFIX_MAP "$srcdir=MACROTEST" } */
+
+int
+main ()
+{
+  if (__builtin_strcmp (__FILE__, "MACROTEST/gcc.dg/cpp/build_path_prefix_map-1.c") != 0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc-7-20170319/gcc/testsuite/gcc.dg/cpp/build_path_prefix_map-2.c
===================================================================
--- /dev/null
+++ gcc-7-20170319/gcc/testsuite/gcc.dg/cpp/build_path_prefix_map-2.c
@@ -0,0 +1,11 @@
+/* __FILE__ should not be relative if BUILD_PATH_PREFIX_MAP is not set, and gcc is
+   asked to compile an absolute filename as is the case with this test.  */
+/* { dg-do run } */
+
+int
+main ()
+{
+  if (__builtin_strcmp (__FILE__, "./gcc.dg/cpp/build_path_prefix_map-1.c") == 0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc-7-20170319/gcc/testsuite/gcc.dg/debug/dwarf2/build_path_prefix_map-1.c
===================================================================
--- /dev/null
+++ gcc-7-20170319/gcc/testsuite/gcc.dg/debug/dwarf2/build_path_prefix_map-1.c
@@ -0,0 +1,9 @@
+/* DW_AT_comp_dir should be relative if BUILD_PATH_PREFIX_MAP is a prefix of it.  */
+/* { dg-do compile } */
+/* { dg-options "-gdwarf -dA" } */
+/* { dg-set-compiler-env-var BUILD_PATH_PREFIX_MAP "[file dirname [pwd]]=DWARF2TEST" } */
+/* { dg-final { scan-assembler "DW_AT_comp_dir: \"DWARF2TEST/gcc" } } */
+
+void func (void)
+{
+}
Index: gcc-7-20170319/gcc/testsuite/gcc.dg/debug/dwarf2/build_path_prefix_map-2.c
===================================================================
--- /dev/null
+++ gcc-7-20170319/gcc/testsuite/gcc.dg/debug/dwarf2/build_path_prefix_map-2.c
@@ -0,0 +1,8 @@
+/* DW_AT_comp_dir should be absolute if BUILD_PATH_PREFIX_MAP is not set.  */
+/* { dg-do compile } */
+/* { dg-options "-gdwarf -dA" } */
+/* { dg-final { scan-assembler "DW_AT_comp_dir: \"/" } } */
+
+void func (void)
+{
+}
Index: gcc-7-20170319/include/prefix-map.h
===================================================================
--- /dev/null
+++ gcc-7-20170319/include/prefix-map.h
@@ -0,0 +1,68 @@
+/* Declarations for manipulating filename prefixes.
+
+   Copyright (C) 2016 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _PREFIX_MAP_H
+#define _PREFIX_MAP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+/* Linked-list of mappings from old prefixes to new prefixes.  */
+
+struct prefix_map
+{
+  const char *old_prefix;
+  const char *new_prefix;
+  size_t old_len;
+  size_t new_len;
+  struct prefix_map *next;
+};
+
+struct prefix_maps
+{
+  struct prefix_map *head;
+  size_t max_replace;
+};
+
+const char *
+apply_prefix_map (const char *old_name, char *new_name,
+		  struct prefix_map *map_head);
+
+#define remap_prefix_alloca(filename, maps, newname) \
+  ((newname) = (char *) alloca (strlen ((filename)) + (maps)->max_replace + 1), \
+  apply_prefix_map ((filename), (newname), (maps)->head))
+
+const char *
+remap_prefix_alloc (const char *filename, struct prefix_maps *maps, void *(*alloc)(size_t size));
+
+const char *
+remap_prefix (const char *filename, struct prefix_maps *maps);
+
+int
+parse_prefix_maps (const char *arg, struct prefix_maps *maps);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PREFIX_MAP_H */
Index: gcc-7-20170319/libcpp/include/cpplib.h
===================================================================
--- gcc-7-20170319.orig/libcpp/include/cpplib.h
+++ gcc-7-20170319/libcpp/include/cpplib.h
@@ -607,6 +607,9 @@ struct cpp_callbacks
   /* Callback to parse SOURCE_DATE_EPOCH from environment.  */
   time_t (*get_source_date_epoch) (cpp_reader *);
 
+  /* Callback to parse BUILD_PATH_PREFIX_MAP from environment.  */
+  struct prefix_maps *(*get_build_path_prefix_map) (cpp_reader *);
+
   /* Callback for providing suggestions for misspelled directives.  */
   const char *(*get_suggestion) (cpp_reader *, const char *, const char *const *);
 };
Index: gcc-7-20170319/libcpp/init.c
===================================================================
--- gcc-7-20170319.orig/libcpp/init.c
+++ gcc-7-20170319/libcpp/init.c
@@ -261,6 +261,9 @@ cpp_create_reader (enum c_lang lang, cpp
   /* Initialize source_date_epoch to -2 (not yet set).  */
   pfile->source_date_epoch = (time_t) -2;
 
+  /* Initialize build_path_prefix_map to NULL (not yet set).  */
+  pfile->build_path_prefix_map = NULL;
+
   /* The expression parser stack.  */
   _cpp_expand_op_stack (pfile);
 
Index: gcc-7-20170319/libcpp/internal.h
===================================================================
--- gcc-7-20170319.orig/libcpp/internal.h
+++ gcc-7-20170319/libcpp/internal.h
@@ -507,6 +507,11 @@ struct cpp_reader
      set to -1 to disable it or to a non-negative value to enable it.  */
   time_t source_date_epoch;
 
+  /* Externally set prefix-map to transform absolute paths, useful for
+     reproducibility.  It should be initialized to NULL (not yet set or
+     disabled) or to a `struct prefix_map` value to enable it.  */
+  struct prefix_maps *build_path_prefix_map;
+
   /* EOF token, and a token forcing paste avoidance.  */
   cpp_token avoid_paste;
   cpp_token eof;
Index: gcc-7-20170319/libcpp/macro.c
===================================================================
--- gcc-7-20170319.orig/libcpp/macro.c
+++ gcc-7-20170319/libcpp/macro.c
@@ -26,6 +26,7 @@ along with this program; see the file CO
 #include "system.h"
 #include "cpplib.h"
 #include "internal.h"
+#include "prefix-map.h"
 
 typedef struct macro_arg macro_arg;
 /* This structure represents the tokens of a macro argument.  These
@@ -290,8 +291,22 @@ _cpp_builtin_macro_text (cpp_reader *pfi
       {
 	unsigned int len;
 	const char *name;
+	char *newname;
 	uchar *buf;
+	prefix_maps *map = pfile->build_path_prefix_map;
 	
+	/* Set a prefix-map for __FILE__ if BUILD_PATH_PREFIX_MAP is defined.  */
+	if (map == NULL && pfile->cb.get_build_path_prefix_map != NULL)
+	  {
+	    map = pfile->build_path_prefix_map = pfile->cb.get_build_path_prefix_map (pfile);
+	    if (map == NULL)
+	      {
+		/* Set a dummy value to avoid doing the check again.  */
+		map = pfile->build_path_prefix_map = XNEW (prefix_maps);
+		memset (map, 0, sizeof (prefix_maps));
+	      }
+	  }
+
 	if (node->value.builtin == BT_FILE)
 	  name = linemap_get_expansion_filename (pfile->line_table,
 						 pfile->line_table->highest_line);
@@ -301,6 +316,13 @@ _cpp_builtin_macro_text (cpp_reader *pfi
 	    if (!name)
 	      abort ();
 	  }
+
+	/* Strip build_path_prefix_map from name, if it's a prefix.  */
+	if (map != NULL && map->head != NULL)
+	  {
+	    name = remap_prefix_alloca (name, map, newname);
+	  }
+
 	len = strlen (name);
 	buf = _cpp_unaligned_alloc (pfile, len * 2 + 3);
 	result = buf;
Index: gcc-7-20170319/libiberty/Makefile.in
===================================================================
--- gcc-7-20170319.orig/libiberty/Makefile.in
+++ gcc-7-20170319/libiberty/Makefile.in
@@ -143,6 +143,7 @@ CFILES = alloca.c argv.c asprintf.c atex
 	 pex-common.c pex-djgpp.c pex-msdos.c pex-one.c			\
 	 pex-unix.c pex-win32.c						\
          physmem.c putenv.c						\
+	prefix-map.c \
 	random.c regex.c rename.c rindex.c				\
 	rust-demangle.c							\
 	safe-ctype.c setenv.c setproctitle.c sha1.c sigsetmask.c        \
@@ -182,6 +183,7 @@ REQUIRED_OFILES =							\
 	./partition.$(objext) ./pexecute.$(objext) ./physmem.$(objext)	\
 	./pex-common.$(objext) ./pex-one.$(objext)			\
 	./@pexecute@.$(objext) ./vprintf-support.$(objext)		\
+	./prefix-map.$(objext) \
 	./rust-demangle.$(objext)					\
 	./safe-ctype.$(objext)						\
 	./simple-object.$(objext) ./simple-object-coff.$(objext)	\
@@ -757,7 +759,7 @@ $(CONFIGURED_OFILES): stamp-picdir stamp
 	$(COMPILE.c) $(srcdir)/fibheap.c $(OUTPUT_OPTION)
 
 ./filename_cmp.$(objext): $(srcdir)/filename_cmp.c config.h $(INCDIR)/ansidecl.h \
-	$(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
+	$(INCDIR)/filenames.h $(INCDIR)/hashtab.h $(INCDIR)/libiberty.h \
 	$(INCDIR)/safe-ctype.h
 	if [ x"$(PICFLAG)" != x ]; then \
 	  $(COMPILE.c) $(PICFLAG) $(srcdir)/filename_cmp.c -o pic/$@; \
@@ -1104,7 +1106,8 @@ $(CONFIGURED_OFILES): stamp-picdir stamp
 	$(COMPILE.c) $(srcdir)/pex-one.c $(OUTPUT_OPTION)
 
 ./pex-unix.$(objext): $(srcdir)/pex-unix.c config.h $(INCDIR)/ansidecl.h \
-	$(INCDIR)/libiberty.h $(srcdir)/pex-common.h
+	$(INCDIR)/environ.h $(INCDIR)/libiberty.h \
+	$(srcdir)/pex-common.h
 	if [ x"$(PICFLAG)" != x ]; then \
 	  $(COMPILE.c) $(PICFLAG) $(srcdir)/pex-unix.c -o pic/$@; \
 	else true; fi
@@ -1143,6 +1146,15 @@ $(CONFIGURED_OFILES): stamp-picdir stamp
 	else true; fi
 	$(COMPILE.c) $(srcdir)/physmem.c $(OUTPUT_OPTION)
 
+./prefix-map.$(objext): $(srcdir)/prefix-map.c config.h $(INCDIR)/prefix-map.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/prefix-map.c -o pic/$@; \
+	else true; fi
+	if [ x"$(NOASANFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(NOASANFLAG) $(srcdir)/prefix-map.c -o noasan/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/prefix-map.c $(OUTPUT_OPTION)
+
 ./putenv.$(objext): $(srcdir)/putenv.c config.h $(INCDIR)/ansidecl.h
 	if [ x"$(PICFLAG)" != x ]; then \
 	  $(COMPILE.c) $(PICFLAG) $(srcdir)/putenv.c -o pic/$@; \
@@ -1210,7 +1222,8 @@ $(CONFIGURED_OFILES): stamp-picdir stamp
 	else true; fi
 	$(COMPILE.c) $(srcdir)/safe-ctype.c $(OUTPUT_OPTION)
 
-./setenv.$(objext): $(srcdir)/setenv.c config.h $(INCDIR)/ansidecl.h
+./setenv.$(objext): $(srcdir)/setenv.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/environ.h
 	if [ x"$(PICFLAG)" != x ]; then \
 	  $(COMPILE.c) $(PICFLAG) $(srcdir)/setenv.c -o pic/$@; \
 	else true; fi
@@ -1661,7 +1674,7 @@ $(CONFIGURED_OFILES): stamp-picdir stamp
 	$(COMPILE.c) $(srcdir)/xexit.c $(OUTPUT_OPTION)
 
 ./xmalloc.$(objext): $(srcdir)/xmalloc.c config.h $(INCDIR)/ansidecl.h \
-	$(INCDIR)/libiberty.h
+	$(INCDIR)/environ.h $(INCDIR)/libiberty.h
 	if [ x"$(PICFLAG)" != x ]; then \
 	  $(COMPILE.c) $(PICFLAG) $(srcdir)/xmalloc.c -o pic/$@; \
 	else true; fi
@@ -1719,3 +1732,4 @@ $(CONFIGURED_OFILES): stamp-picdir stamp
 	  $(COMPILE.c) $(PICFLAG) $(NOASANFLAG) $(srcdir)/xvasprintf.c -o noasan/$@; \
 	else true; fi
 	$(COMPILE.c) $(srcdir)/xvasprintf.c $(OUTPUT_OPTION)
+
Index: gcc-7-20170319/libiberty/prefix-map.c
===================================================================
--- /dev/null
+++ gcc-7-20170319/libiberty/prefix-map.c
@@ -0,0 +1,224 @@
+/* Definitions for manipulating filename prefixes.
+
+   Copyright (C) 2016 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include "filenames.h"
+#include "libiberty.h"
+#include "prefix-map.h"
+
+
+/* Add a new mapping.
+ *
+ * The input strings are duplicated and a new prefix_map struct is allocated.
+ * Ownership of the duplicates, as well as the new prefix_map, is the same as
+ * the owner of the overall prefix_maps struct.
+ *
+ * Returns 0 on failure and 1 on success.
+ */
+int
+add_prefix_map (const char *new_prefix, const char *old_prefix,
+		struct prefix_maps *maps)
+{
+  struct prefix_map *map = XNEW (struct prefix_map);
+  if (!map)
+    goto rewind_0;
+
+  map->old_prefix = xstrdup (old_prefix);
+  if (!map->old_prefix)
+    goto rewind_1;
+  map->old_len = strlen (old_prefix);
+
+  map->new_prefix = xstrdup (new_prefix);
+  if (!map->new_prefix)
+    goto rewind_2;
+  map->new_len = strlen (new_prefix);
+
+  map->next = maps->head;
+  maps->head = map;
+
+  if (map->new_len > maps->max_replace)
+    maps->max_replace = map->new_len;
+
+  return 1;
+
+rewind_2:
+  free ((void *) map->old_prefix);
+rewind_1:
+  free (map);
+rewind_0:
+  return 0;
+}
+
+
+/* Clear all mappings.
+ *
+ * All child structs of [maps] are freed, but it itself is not freed.
+ */
+void
+clear_prefix_maps (struct prefix_maps *maps)
+{
+  struct prefix_map *map;
+  struct prefix_map *next;
+
+  for (map = maps->head; map; map = next)
+    {
+      free ((void *) map->old_prefix);
+      free ((void *) map->new_prefix);
+      next = map->next;
+      free (map);
+    }
+
+  maps->max_replace = 0;
+}
+
+
+/* Private function, assumes new_name is wide enough to hold the remapped name. */
+const char *
+apply_prefix_map (const char *old_name, char *new_name,
+		  struct prefix_map *map_head)
+{
+  struct prefix_map *map;
+  const char *name;
+
+  for (map = map_head; map; map = map->next)
+    if (strncmp (old_name, map->old_prefix, map->old_len) == 0)
+      break;
+  if (!map)
+    return old_name;
+
+  name = old_name + map->old_len;
+  memcpy (new_name, map->new_prefix, map->new_len);
+  memcpy (new_name + map->new_len, name, strlen (name) + 1);
+  return new_name;
+}
+
+
+/* Remap a filename.
+ *
+ * This function does not consume nor take ownership of filename; the caller is
+ * responsible for freeing it, if and only if it was already responsible for
+ * freeing it before the call.
+ *
+ * It allocates new memory only in the case that a mapping was made. That is,
+ * if and only if filename != return-value, then the caller is responsible for
+ * freeing return-value.
+*/
+const char *
+remap_prefix_alloc (const char *filename, struct prefix_maps *maps, void *(*alloc)(size_t size))
+{
+  char *newname;
+  const char *name = remap_prefix_alloca (filename, maps, newname);
+
+  if (name == filename)
+    return filename;
+
+  size_t len = strlen (newname) + 1;
+  return (char *) memcpy (alloc (len), newname, len);
+}
+
+
+/* Like remap_prefix_alloc but with the system allocator. */
+const char *
+remap_prefix (const char *filename, struct prefix_maps *maps)
+{
+  return remap_prefix_alloc (filename, maps, malloc);
+}
+
+/** Parsing the variable. */
+/* For Applying the variable, and Main program, see prefix_map.h. */
+
+int
+unquote (char *src)
+{
+  for (char *dest = src; 0 != (*dest = *src); ++dest, ++src)
+    switch (*src)
+      {
+      case ':':
+      case '=':
+	return 0; // should have been escaped
+      case '%':
+	switch (*(src + 1))
+	  {
+	  case '.':
+	    *dest = ':';
+	    goto unquoted;
+	  case '+':
+	    *dest = '=';
+	  unquoted:
+	  case '#':
+	    ++src;
+	    break;
+	  default:
+	    return 0; // invalid
+	  }
+      }
+  return 1;
+}
+
+/* Returns 0 on failure and 1 on success. */
+int
+parse_prefix_map (char *arg, struct prefix_maps *maps)
+{
+  char *p;
+  p = strchr (arg, '=');
+  if (!p)
+    return 0;
+  *p = '\0';
+  if (!unquote (arg))
+    return 0;
+  p++;
+  if (!unquote (p))
+    return 0;
+
+  return add_prefix_map (arg, p, maps);
+}
+
+/* Returns 0 on failure and 1 on success. */
+int
+parse_prefix_maps (const char *arg, struct prefix_maps *maps)
+{
+  size_t len = strlen (arg);
+  char *copy = (char *) alloca (len + 1);
+  memcpy (copy, arg, len + 1); // strtok modifies the string so we have to copy it
+
+  char *sep = ":", *end;
+  char *tok = strtok_r (copy, sep, &end);
+  while (tok != NULL)
+    {
+      if (!parse_prefix_map (tok, maps))
+	{
+	  fprintf (stderr, "invalid value for prefix-map: '%s'\n", arg);
+	  return 0;
+	}
+
+      tok = strtok_r (NULL, sep, &end);
+    }
+
+  return 1;
+}
Index: gcc-7-20170319/gcc/debug.h
===================================================================
--- gcc-7-20170319.orig/gcc/debug.h
+++ gcc-7-20170319/gcc/debug.h
@@ -236,6 +236,7 @@ extern void dwarf2out_switch_text_sectio
 
 const char *remap_debug_filename (const char *);
 void add_debug_prefix_map (const char *);
+void add_debug_prefix_map_from_envvar ();
 
 /* For -fdump-go-spec.  */
 
